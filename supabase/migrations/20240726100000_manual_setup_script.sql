-- This script is intended for manual execution in the Supabase SQL Editor
-- if automatic migrations fail.

-- 1. Create the 'users' table to store user information
CREATE TABLE IF NOT EXISTS public.users (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    email character varying,
    role character varying DEFAULT 'member'::character varying,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
ALTER TABLE public.users OWNER TO postgres;
ALTER TABLE ONLY public.users ADD CONSTRAINT users_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.users ADD CONSTRAINT users_email_key UNIQUE (email);

-- 2. Create the 'policies' table for warranty data
CREATE TABLE IF NOT EXISTS public.policies (
    "policyNumber" character varying NOT NULL,
    "customerName" text,
    "customerEmail" text,
    "customerPhone" text,
    "tireDot" text,
    "purchaseDate" date,
    "warrantyEndDate" date,
    "receiptUrl" text,
    "policyDocument" text,
    "vehicleYear" integer,
    "vehicleMake" text,
    "vehicleModel" text,
    "vehicleMileage" integer,
    "dealerName" text,
    "invoiceNumber" text,
    "roadHazardPrice" numeric,
    "pricePerTire" numeric,
    "tireQuantity" integer,
    "tireDot1" text,
    "tireDot2" text,
    "tireDot3" text,
    "tireDot4" text,
    "tireDot5" text,
    "tireDot6" text,
    "customerStreet" text,
    "customerCity" text,
    "customerState" text,
    "customerZip" text,
    "vehicleSubmodel" text,
    "isCommercial" boolean,
    "tireBrand" text,
    "tireModel" text,
    "tireSize" text,
    "created_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE public.policies OWNER TO postgres;
ALTER TABLE ONLY public.policies ADD CONSTRAINT policies_pkey PRIMARY KEY ("policyNumber");

-- 3. Enable Row Level Security (RLS) on the tables
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.policies ENABLE ROW LEVEL SECURITY;

-- 4. Apply Row Level Security Policies
-- Drop existing policies if they exist, to prevent errors on re-run
DROP POLICY IF EXISTS "Authenticated users can view users" ON public.users;
DROP POLICY IF EXISTS "Authenticated users can insert users" ON public.users;
DROP POLICY IF EXISTS "Authenticated users can delete users" ON public.users;
DROP POLICY IF EXISTS "Public can view all policies" ON public.policies;
DROP POLICY IF EXISTS "Authenticated users can insert policies" ON public.policies;

-- Create policies for the 'users' table
CREATE POLICY "Authenticated users can view users" ON public.users FOR SELECT TO authenticated USING (true);
CREATE POLICY "Authenticated users can insert users" ON public.users FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Authenticated users can delete users" ON public.users FOR DELETE TO authenticated USING (true);

-- Create policies for the 'policies' table
CREATE POLICY "Public can view all policies" ON public.policies FOR SELECT TO public USING (true);
CREATE POLICY "Authenticated users can insert policies" ON public.policies FOR INSERT TO authenticated WITH CHECK (true);


-- 5. Set up Storage: Create the 'receipts' bucket
-- This command is idempotent, it won't fail if the bucket already exists.
INSERT INTO storage.buckets (id, name, public)
VALUES ('receipts', 'receipts', true)
ON CONFLICT(id) DO NOTHING;

-- 6. Apply Storage Policies to allow uploads and downloads
-- Drop existing policies if they exist, to prevent errors on re-run
DROP POLICY IF EXISTS "Authenticated users can upload receipts" ON storage.objects;
DROP POLICY IF EXISTS "Public can view receipts" ON storage.objects;

-- Create policies for storage access
CREATE POLICY "Authenticated users can upload receipts" ON storage.objects
FOR INSERT TO authenticated
WITH CHECK ( bucket_id = 'receipts' );

CREATE POLICY "Public can view receipts" ON storage.objects
FOR SELECT TO public
USING ( bucket_id = 'receipts' );
